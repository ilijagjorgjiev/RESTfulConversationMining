<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>RESTful Conversation Mining</title>

  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <script src="bower_components/graphlib/dist/graphlib.core.js"></script>
  <script src="bower_components/dagre/dist/dagre.core.js"></script>
  <script src="bower_components/dagre-d3/dist/dagre-d3.core.js"></script>
  <link rel="stylesheet/less" type="text/css" href="bower_components/tyles.less" />
  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <script type="text/javascript" src="https://www.google.com/jsapi"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <!-- <script src="firstData.js"></script> -->
  <!-- <script src="routesData.js"></script> -->
  <!-- <script src="data.js"></script> -->
  <script src="sqrfun.js"></script>
  <script src="stylingfun.js"></script>
  <script src="patternMatching.js"></script>
  <script src="patternData.js"></script>
  <script src="bower_components/jquery/dist/jquery.js"></script>
  <!-- <script type="text/javascript" src="setup.js"></script> -->
  <link rel="stylesheet" href="styles.css">

  <body>
    <div id="Container" style="display: flex">
      <button onclick="goBack()">Go Back</button>
      <div id="Clients" style="float: left">
        <select id="multiSelect-Clients" multiple="multiple">
        </select>
        <!-- <button class="dropbtn" onmouseover="displayClients()">Clients</button> -->
      </div>
      <select id="multiSelect" multiple="multiple">
      </select>
      <button id="multiSelectForm" type="submit"/> Draw </button>
      <div id="Btns">
      </div>
      <div id="VisualizationConfig" style="display: none">
        Node Frequency Coloring: <input type="checkbox" id="nfc" onclick="myFunction()"> <br />
        Edge Frequency Thickness: <input type="checkbox" id="eft" onclick="myFunction1()"> <br />
        Edge Delay Coloring: <input type="checkbox" id="edc" onclick="myFunction2()"> <br />
        Show Edge Probability: <input type="checkbox" id="sep" onclick="myFunction3()"> <br />
        Status Coloring: <input type="checkbox" id="statusColoring"> <br />
        <form  id="formId" onsubmit="getPattern()">
          <input type="file" name="fname" id="dataId" style="display: none;">
          <input type="button" value="Add a Pattern" onclick="document.getElementById('dataId').click();" />
          <input type="submit" />
        </form>
      </div>
    <div id="patternMenu">
      <select id="predefinedPatterns"></select>
      <div id=patternButtons style="display: block">
        <button id="visualizePattern" onclick="visualizePattern()"> Visualize </button>
        <button id="hasPattern" onclick="hasPatternClick()"> Search Graph </button>
      </div>
    </div>
      <div id="piechart"></div>
      <!-- <svg width="200px" height="200px"></svg> -->
    </div>
    <div style="display: flex">
      <svg id="restalk"> </g></svg>
      <div id="pieCharts">
        <div id="piechart-1">

        </div>
        <div id="piechart-2">

        </div>
        <div id="piechart-3">

        </div>
  </body>
  <script>
  //Get the Data
  var clients = localStorage.getItem('objectToPass');
  clients = JSON.parse(clients);

  // Create the list of Clients.
  var displayClients = function(){
    let i = 0;
    var div = document.getElementById("multiSelect-Clients");
    var str = '';
    for(let client in clients){
      let option = document.createElement("option");
      option.onmouseenter = function(){
        displayTimePeriods(client);
      }
      let linkText = document.createTextNode(i+"-"+client);
      option.value = i+"-"+client;
      option.appendChild(linkText);
      div.appendChild(option);
      i++;
      // str+=('<option value=' + client + 'onmouseenter="displayTimePeriods(\''+ client +'\')" onclick="drawGraph(\''+client +'\')"> '+ client + '</option> ');
    }
  }

  displayClients();
  // localStorage.removeItem('objectToPass');
  //LOAD Google Charts
  var globalGraph, globalNodes;
  google.load("visualization", "1", {packages:["corechart"]});
  // google.charts.setOnLoadCallback(createPieChart);
  // Input related code goes here
  function getPattern(e){
    var x = e.preventDefault();
    var file = document.getElementById('dataId');

    if(file.files.length)
    {
      var reader = new FileReader();

      reader.onload = function(e)
      {
        pattern = e.target.result;
        console.log("here");
        hasPattern(g, globalNodes, patternMixed);
      }
    }
  }
    $(document).ready(function(){
      var form = document.getElementById("formId")
      form.onsubmit = getPattern;
    })
    var displayPatterns = function(){
      var div = document.getElementById("predefinedPatterns");
      for(let pattern in user_select_patterns){
        let obj = user_select_patterns[pattern];
        let option = document.createElement("option");
        let linkText = document.createTextNode(pattern);
        option.appendChild(linkText);
        option.value = pattern;
        div.appendChild(option);
      }
    }
    displayPatterns();
    var checkPatterns = function(pattern){

      if(globalGraph === undefined) console.log("GLOBAL GRAPH NOT SET UP")
      else{
        clearPatternMenu();
        let obj = hasPattern(globalGraph, globalNodes, pattern);
        if(obj.bool){
          let div = document.getElementById("patternButtons");
          let newDiv = document.createElement("div");
          var x = document.createElement("INPUT");
          x.setAttribute("id", "vizPatternGraph");
          x.setAttribute("type", "checkbox");
          let label = document.createElement("LABEL");
          label.setAttribute("for", "vizPatternGraph");
          setUpPatternVisualization(globalGraph, obj.matrixNodesVisualization);
          x.onclick = function(){
            let elem = document.getElementById("vizPatternGraph");
            var y = document.getElementsByTagName("STYLE")[5];
            if(elem.checked){
              y.disabled = false;
            }
            else{
              y.disabled = true;
            }
          }
          let btn2 = document.createElement("p");
          let txt1 = document.createTextNode("VisualizePatternInGraph")
          let txt2 = document.createTextNode("Pattern was FOUND")
          label.appendChild(txt1);
          btn2.appendChild(txt2);
          div.appendChild(btn2);
          newDiv.appendChild(x);
          div.appendChild(x);
          div.appendChild(label);
        }
      }
    }
    var clearPatternMenu = function(){
      let div = document.getElementById("patternButtons");
      let x = document.getElementsByTagName("STYLE");
      let btn1 = document.createElement("BUTTON");
      let btn2 = document.createElement("BUTTON");
      let txt1 = document.createTextNode("Visualize");
      let txt2 = document.createTextNode("Search Graph");
      btn1.onclick = visualizePattern;
      btn2.onclick = hasPatternClick;
      btn1.appendChild(txt1);
      btn2.appendChild(txt2);
      while(div.hasChildNodes()) div.removeChild(div.childNodes[0])
      x[5].remove();
      div.appendChild(btn1);
      div.appendChild(btn2);
    }
    var visualizePattern = function(){
      
    }
    var disablePatternStyle = function(){
      let elem = document.getElementById("vizPatternGraph");
      var y = document.getElementsByTagName("STYLE")[5];
      if(elem.checked){
        y.disabled = true
        elem.checked = false;
      }
    }
    // var clearPatternVisualization(){
    //   // var x = document.getElementsByTagName("STYLE")[5];
    //   // x.disabled = true;
    // }
    var hasPatternClick = function(){
      if(globalGraph === undefined) console.log("Draw a graph")
      else{
          var section = document.getElementById("predefinedPatterns");
          var options = section && section.options;
          var value = options[options.selectedIndex].value;
          checkPatterns(user_select_patterns[value]);
      }
    }
    var displayTimePeriods = function(clientIP){
      var client = this.clients[clientIP];
      var el = document.getElementById("multiSelect");
      var form = document.getElementById("multiSelectForm");
      var timePeriods = differenceThreshold(client);
      var str = "";
      for(let i = 0; i < timePeriods.length; i++){
        str += '<option value=\''+i+'\'> Time Period '+ i + '</option>'
      }
      form.onclick = function(){
        var elem1 = document.getElementById("multiSelect");
        var elem2 = document.getElementById("multiSelect-Clients");
        var ret1 = getSelectedIPs(timePeriods, elem1);
        var ret2 = getSelectedIPs(clients, elem2);

        if(Object.keys(ret1).length) drawGraph(ret1);
        else drawGraph(ret2);
      }
      el.innerHTML = str;
    }
    var fixVisualizationConfig = function(nfc, eft, edc, sep, statusColoring){

      nfc.checked = false;
      eft.checked = false;
      edc.checked = false;
      sep.checked = false;
      statusColoring.checked = false;
      deleteStyles();
      disableConversionPaths();
      // clearTable();
      // disableEdgeProbability();
    }
    //Draw the Graph for the selected IP.
    var drawGraph = function(dataObject){
      var g = new dagreD3.graphlib.Graph()
      .setGraph({})
      .setDefaultEdgeLabel(function() { return {}; });
      globalGraph = g;
      var nfc = document.getElementById("nfc");
      var eft = document.getElementById("eft");
      var edc = document.getElementById("edc");
      var sep = document.getElementById("sep");
      var statusColoring = document.getElementById("statusColoring");

      fixVisualizationConfig(nfc, eft, edc, sep, statusColoring);
      // Here we"re setting nodeclass, which is used by our custom drawNodes function
      // below.
      var statusObj = {};
      var obj;
      var endConnections = {};
      var nodes = []
      var incomingXorNodes = {}
      var totalTpIpArray = []
      var startKey, startStatus;
      var comparisonTableData = {
        timePorIP : [],
        uniqueOverlapping : {
          uniqueNodes : {
            size : 0,
          },
          overlappingNodes : {
            size : 0,
          },
          uniqueEdges : { size : 0,},
          overlappingEdges : {size : 0,},
        },
        uniqueness : {},
        uniquenessNodes : {},
        nodeIpTp : {},
      }
      for(let client in dataObject){
        let start = "start-"+client;
        g.setNode(start, {shape: "circle", class : "start" + " tpIpColoring-"+client});
        g.setNode("end-"+client, {shape: "circle", style: "stroke-width: 4; stroke: black", class : "start" + " tpIpColoring-"+client})
        let length = dataObject[client].length;
        let cl = dataObject[client];
        obj = seqPreservingComparison(cl, length, nodes, start, incomingXorNodes, "end-"+client, client, comparisonTableData);
        totalTpIpArray.push(client);
        incomingXorNodes = obj.incomingXorNodes;
        endConnections[client]= obj.endConnection.e1;
        comparisonTableData.timePorIP.push(client);
        nodes = obj.nodes;
      }
      var totalRequestsData = totalNumberOfRequests(nodes);
      var totalRequests = totalRequestsData.total;
      var maxRequests = totalRequestsData.maxRequests;
      // comparisonTableData.uniqueOverlapping = getComparisonTableNodes(nodes, comparisonTableData.uniqueOverlapping);
      for(var key in nodes){
        var size = Object.keys(nodes[key]).length;
        if(size == 1){
          var status = Object.keys(nodes[key])[0]
          var str = "inXOR-"+key
          var word = setUpClassForDifferentIpTp(nodes, key, status);
          updateComparisonUniqueness(word, comparisonTableData, key, status);
          hasStatus(statusObj, status);
          let patternClazz = getPatternClassName(key, status);
          if(incomingXorNodes[key] !== undefined) checkIfIncomingXorExists(nodes, key, incomingXorNodes, Object.keys(incomingXorNodes[key]).length, "inXOR-"+key)
          g.setNode(key+' '+status, { shape: "rect", label : nodes[key][status].statusArray[0].key + '\n' + status + '\n' + nodes[key][status].statusArray.length,
          class:"type-Request method-"+key+' '+status + ' ' + patternClazz + ' ' + word + ' ' + "status-"+status});
          if(nodes[key][status].outgoingXOR){
            g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR outgoingXOR"});
          }
          if((nodes[key][status].statusArray.length) > 1 && Object.keys(incomingXorNodes[key]).length > 1){
            // var bool = checkIfIncomingXorExists(nodes, key, status, incomingXorNodes, Object.keys(incomingXorNodes[key]).length, "inXor-"+key);
            var str = "inXOR-"+key
            g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR incomingXOR"});
          }
        }
        else{
          var st = Object.keys(nodes[key])[0]
          var word = setUpTotalClassForDifferentIpTp(nodes, key);
          let patternClazz = getPatternClassName(key, undefined);
          updateComparisonUniqueness(word, comparisonTableData, key, undefined);
          g.setNode(key, {shape: "rect", label: nodes[key][st].statusArray[0].key + '\n' + totalRequests[key], class: "type-Request method-"+key+' '+patternClazz + ' ' + word});
          g.setNode("middleXOR-"+key,{label: "XOR", shape: "diamond", class: "type-XOR middleXOR"});
          var str = "inXOR-"+key
          if(Object.keys(incomingXorNodes[key]).length > 1) g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR incomingXOR"});
          for(var status in nodes[key]){
            word = setUpClassForDifferentIpTp(nodes, key, status);
            patternClazz = getPatternClassName(key, status);
            updateComparisonUniqueness(word, comparisonTableData, key, status);
            hasStatus(statusObj, status);
            g.setNode(key+' '+status, {shape: "rect", label : status + '\n' + nodes[key][status].statusArray.length, class:"type-Response method-"+key+' '+status +' '+ patternClazz + ' ' + word + ' ' + "status-"+status});
            if(nodes[key][status].outgoingXOR){
              g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR outgoingXOR"});
            }
          }
        }
      }

      //Compute Delay Avgs
      obj = computeMinMaxAvgDelayVal(nodes);
      nodes = obj.nodes;
      var totalAvgKey = obj.totalAvgKey;
      var maxDelay = obj.MAX;
      var minDelay = obj.MIN;
      var edges = 0;
      //Set Up Edges
      for(var key in nodes){
        var str = "inXOR-"+key
        var size = Object.keys(nodes[key]).length
        var bin = computeAssignBin(totalAvgKey[key].totalDelayAvgKey, maxDelay, 1);
        if(size == 1){
          var status = Object.keys(nodes[key])[0]
          if(nodes[key][status].outgoingXOR){
            // console.log("OUTGOING-Size-1");
            g.setEdge(key+' '+status,"XOR-"+key+' '+status,
            {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin});
            // increaseAppropriateEdge(size, key, status, comparisonTableData.uniqueOverlapping, "outgoingXOR");
            edges++;
            // console.log(key, status)
            // g.setEdge("inXOR-"+key, key+' '+status, {label: "delayAvg: "+ delayAvg});
          }
          if(nodes[key][status].statusArray.length > 1 && Object.keys(incomingXorNodes[key]).length == 1){
            let space = Object.keys(incomingXorNodes[key])[0]
            let p = getProbabilityLabel(nodes, nodes[key][status].statusArray[0].start.split(' ')[0], nodes[key][status].statusArray[0].start.split(' ')[1], incomingXorNodes[key][space].length);
            g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status,
            {label: p,
              class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin})
              // console.log("INCOMING-Size-1");
              // increaseAppropriateEdge(size, key, status, comparisonTableData.uniqueOverlapping, "incomingXOR");
              edges++;
            }
            if(nodes[key][status].statusArray.length == 1){
              let p = getProbabilityLabel(nodes, nodes[key][status].statusArray[0].start.split(' ')[0], nodes[key][status].statusArray[0].start.split(' ')[1], 1);
              g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status,
              { label : p,
                class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin})
                // console.log("INCOMING-STATUS-LENGTH-1");
                // increaseAppropriateEdge(size, key, status, comparisonTableData.uniqueOverlapping, "incomingXOR");
                edges++;
              }
              if(nodes[key][status].statusArray.length > 1 && Object.keys(incomingXorNodes[key]).length > 1){
                g.setEdge("inXOR-"+key, key+' '+status,
                {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-"+bin})
                // increaseAppropriateEdge(size, key, status, comparisonTableData.uniqueOverlapping, "incomingXOR");
                edges++;
                // console.log("INCOMING-XOR-SIZE-1")
                // console.log(key, status)
                for(var space in incomingXorNodes[key]){
                  var len = incomingXorNodes[key][space][0].length;
                  if(len == 1){
                    g.setEdge(incomingXorNodes[key][space][0][0], str,
                      {class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-0"})
                      // console.log("it should be start NODE", incomingXorNodes[key][space][0][0])
                      comparisonTableData.uniqueOverlapping.uniqueEdges.size++;
                      edges++;
                    }
                    else{
                      let avg = getIncomingEdgeIndexDelay(nodes, key, incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], incomingXorNodes[key][space].length);
                      bin = computeAssignBin(avg, maxDelay, 1);
                      let p = getProbabilityLabel(nodes, incomingXorNodes[key][space][0][0], incomingXorNodes[key][space][0][1], incomingXorNodes[key][space].length);
                      g.setEdge(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], str,
                      { label : p,
                        class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-"+bin})
                      }
                    }
                  }
                }
                else{
                  var str1 = "middleXOR-"+key;
                  // g.setEdge(str,key,{label: "Delay Average:"+delayAvg});
                  if(Object.keys(incomingXorNodes[key]).length > 1){
                    g.setEdge(str,key, {
                      class: "edge-thickness-"+totalRequests[key] + " " + "delay-coloring-"+bin});
                      // increaseAppropriateEdge(1, key, status, comparisonTableData.uniqueOverlapping, "incomingXOR");
                      edges++;
                    }
                    g.setEdge(key,str1, {class: "edge-thickness-"+totalRequests[key] + " " + "delay-coloring-0"});
                    // increaseAppropriateEdge(1, key, status, comparisonTableData.uniqueOverlapping, "incomingXOR");
                    edges++;
                    for(var status in nodes[key]){
                      // console.log(nodes[key][status].avgDelay);
                      bin = computeAssignBin(nodes[key][status].avgDelay, maxDelay, 1);
                      g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%",
                      class: "edge-thickness-" +nodes[key][status].statusArray.length + " " + "delay-coloring-"+bin})
                      // increaseAppropriateEdge(1, key, status, comparisonTableData.uniqueOverlapping, "middleXOR");
                      edges++;
                      // g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%"+'\n'+"Delay Avg:" + (computeDelayAvg(nodes, key, status)/1000/60/60/24), labelType: "html"});
                      if(nodes[key][status].outgoingXOR){
                        g.setEdge(key+' '+status, "XOR-"+key+' '+status,
                        {class: "edge-thickness-" + nodes[key][status].statusArray.length + " delay-coloring-0"});
                        // increaseAppropriateEdge(1, key, status, comparisonTableData.uniqueOverlapping, "middleXOR");
                        edges++;
                      }
                    }
                    multipleIncomingXorSetUp(g, nodes, key, Object.keys(incomingXorNodes[key]).length, maxDelay, 1, incomingXorNodes)
                  }
                }
                // console.log(comparisonTableData);
                // console.log(edges);
                //Set Up End Node
                for(var end in endConnections){
                  var endConnection = endConnections[end];
                  var spaces =  endConnection.split(' ');
                  var k = spaces[0]
                  var s = spaces[1]
                  if(nodes[k][s].outgoingXOR){
                    g.setEdge("XOR-"+k+' '+s, "end-"+end, {
                      label : roundUp(1/totalRequests[k]*100,1)+"%",
                      class: "edge-thickness-1 delay-coloring-0"})
                    }
                    else{
                      g.setEdge(k+' '+s, "end-"+end, {class: "edge-thickness-1 delay-coloring-0"});
                    }
                  }
                  g.nodes().forEach(function(v) {
                    var node = g.node(v);
                    // console.log(node);
                    // console.log(g.nodes())
                    // Round the corners of the nodes
                    node.rx = node.ry = 5;
                  });
                  // console.log(edges, comparisonTableData);
                  setNodeClasses(g, nodes, totalRequestsData);
                  setVisualizationConfig(nfc, eft, edc, sep, statusColoring, maxRequests, statusObj);
                  // triggerEdgeProbability(sep);
                  var rainbows = conversionPath("tpIpColoring", totalTpIpArray.length, totalTpIpArray, comparisonTableData.uniquenessNodes);
                  var patternFound;
                  var convSharingNodes = createConversationSharingNodes(comparisonTableData.uniquenessNodes);
                  var numOfSharedNodes = createComparisonUniquenessTable(comparisonTableData.uniqueness);
                  var numOfNodes = createComparisonNodeIpTpTable(comparisonTableData.nodeIpTp);
                  // $(document).ready(function(){
                  //   console.log(document.getElementById("piechart-1"));
                  //   displayPieChar(convSharingNodes.data, convSharingNodes.options, "piechart-1");
                  // })
                  // window.onload = function() {
                  //     console.log(document.getElementById("piechart-1"));
                  //     displayPieChar(convSharingNodes.data, convSharingNodes.options, "piechart-1");
                  // };
                  // displayPieChar(convSharingNodes.data, convSharingNodes.options, "piechart-1");
                  // createPieChart(comparisonTableData.uniqueness);
                  globalNodes = nodes;
                  globalGraph = g;
                  // var patternFound2 = hasPattern(g, nodes, patternWild);
                  // hasPatternWholeGraph(g, dataObject.data, patternMixed, startKey, startStatus);
                  // createPieChart();
                  // console.log("PATTERN="+patternFound);
                  // console.log("PatternURL="+patternFound1);
                  // console.log("patternWild="+patternFound2);
                  displayPieChar(numOfNodes.data, numOfNodes.options, "piechart-1", rainbows.nodesRainbow, undefined);
                  displayPieChar(numOfSharedNodes.data, numOfSharedNodes.options, "piechart-2", undefined);
                  displayPieChar(convSharingNodes.data, convSharingNodes.options, "piechart-3", rainbows.pieChartRainbow, comparisonTableData.uniquenessNodes);
                  // console.log(c);
                  renderSvg(g);
                  // displayPieChar(convSharingNodes.data, convSharingNodes.options, "piechart-1");
                  // displayPieChar(numOfNodes.data, numOfNodes.options, "piechart-2");
                  // var svg = d3.select("svg#restalk");
                  // svg.selectAll("*").remove();
                  // var inner = svg.append("g");
                  //
                  // // Set up zoom support
                  // var zoom = d3.zoom().on("zoom", function() {
                  //   inner.attr("transform", d3.event.transform);
                  // });
                  // svg.call(zoom);
                  //
                  // // Create the renderer
                  // var render = new dagreD3.render();
                  // // Run the renderer. This is what draws the final graph.
                  // render(inner, g);
                  // // Center the graph
                  // var initialScale = 0.2;
                  // svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));
                  // svg.selectAll("g.node.start").on("click", function(id) { var _node = g.node(id);
                  //   var n = id.split("start-")[1];
                  //   document.body.classList.toggle("enable-path-"+n);
                  //   console.log("Clicked " + id); });
                }
                var renderSvg = function(g){
                  var svg = d3.select("svg#restalk");
                  svg.select("g").remove();
                  var inner = svg.append("g");

                  // Set up zoom support
                  var zoom = d3.zoom().on("zoom", function() {
                    inner.attr("transform", d3.event.transform);
                  });
                  svg.call(zoom);

                  // Create the renderer
                  var render = new dagreD3.render();
                  // Run the renderer. This is what draws the final graph.
                  render(inner, g);
                  // Center the graph
                  var initialScale = 0.2;
                  svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));
                  svg.selectAll("g.node.start").on("click", function(id) { var _node = g.node(id);
                    var n = id.split("start-")[1];
                    document.body.classList.toggle("enable-path-"+n);
                    console.log("Clicked " + id); });
                  }
                  function goBack() {
                    window.history.back();
                  }
                  function displayPieChar(arr, options, id, rainbow, rules){
                    data = google.visualization.arrayToDataTable(arr);
                    if(id === "piechart-3"){
                      options.colors = []
                      for(var rule in rules){
                        options.colors.push(rainbow[rule]);
                      }
                    }
                    else if (id == "piechart-1"){
                      options.colors = []
                      for(let i in rainbow){
                        options.colors.push(rainbow[i]);
                      }
                    }
                    var chart = new google.visualization.PieChart(document.getElementById(id));
                    chart.style = "display: block";
                    chart.draw(data, options);
                  }
                  // google.charts.load('visualization', '1.0', {packages: ['corechart', 'table', 'controls', 'gauge']});
                  </script>
                  </html>
