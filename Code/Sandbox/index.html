<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dagre Interactive Demo</title>

  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <script src="bower_components/graphlib/dist/graphlib.core.js"></script>
  <script src="bower_components/dagre/dist/dagre.core.js"></script>
  <script src="bower_components/dagre-d3/dist/dagre-d3.core.js"></script>
  <script src="data.js"></script>
  <!-- <script type="text/javascript" src="setup.js"></script> -->
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div>
    <div class="dropdown" style="float: left">
      <button class="dropbtn" onmouseover="displayClients()">Dropdown</button>
    </div>
    <svg> </g></svg>
  </div>
</body>
<script>
// Input related code goes here

// Create the dropdown-list of Clients.
var displayClients = function(){
  var div = document.getElementsByClassName("dropdown");
  var str = '<div class="dropdown-content"> '
  for(var client in clients){
    str+=('<a onclick="drawGraph(\''+client +'\')"> '+ client + '</a> ')
  }
  str+=('</div>')
  div[0].innerHTML += str;
}

//Draw the Graph for the selected IP.
var drawGraph = function(clientIP){
  var g = new dagreD3.graphlib.Graph()
  .setGraph({})
  .setDefaultEdgeLabel(function() { return {}; });

  // Here we"re setting nodeclass, which is used by our custom drawNodes function
  // below.
  g.setNode("start", { shape: "circle" });
  g.setNode("end", {shape: "circle", style: "stroke-width: 4; stroke: black"})

  var length = clients[clientIP].length;
  var obj = seqPreservingComparison(clients, clientIP, length);
  var incomingXorNodes = obj.incomingXorNodes;
  var nodes = obj.nodes;
  var endConection = obj.endConection;
  var client = clients[clientIP];
  // averageTimeDifference(client);


  //Set Up Nodes
  for(var key in nodes){
    var size = Object.keys(nodes[key]).length;
    if(size == 1){
      var status = Object.keys(nodes[key])[0]
      g.setNode(key+' '+status, {label : key + '\n' + status, class:"type-Request method-"+key+' '+status});
      if(nodes[key][status].outgoingXOR){
        g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
        var str = "inXOR-"+key
        g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
      }
    }
    else{
      g.setNode(key, {label: key, class: "type-Request method-"+key});
      g.setNode("middleXOR-"+key,{label: "XOR", shape: "diamond", class: "type-XOR"});
      var str = "inXOR-"+key
      g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
      for(var status in nodes[key]){
        g.setNode(key+' '+status, {label : status, class:"type-Response method-"+key+' '+status});
        if(nodes[key][status].outgoingXOR){
          g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
      }
    }
  }

  //Set Up Edges
  for(var key in nodes){
    var str = "inXOR-"+key
    var size = Object.keys(nodes[key]).length
    if(size == 1){
      var status = Object.keys(nodes[key])[0]
      if(nodes[key][status].outgoingXOR){
        g.setEdge(key+' '+status,"XOR-"+key+' '+status)
        g.setEdge("inXOR-"+key, key+' '+status);
        for(let i = 0; i < incomingXorNodes[key].length; i++){
          var len = incomingXorNodes[key][i].length;
          // console.log(incomindXorNodes[])
          if(len == 1){
            g.setEdge(incomingXorNodes[key][i][0], str)
          }
          else{
            g.setEdge(incomingXorNodes[key][i][0]+' '+incomingXorNodes[key][i][1], str)
          }
        }
      }
      else{
        g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status);
      }
    }
    else{
      var str1 = "middleXOR-"+key;
      g.setEdge(str,key);
      g.setEdge(key,str1);
      for(var status in nodes[key]){
        g.setEdge(str1,key+' '+status);
        if(nodes[key][status].outgoingXOR){
          g.setEdge(key+' '+status, "XOR-"+key+' '+status);
        }
        for(let i = 0; i < incomingXorNodes[key].length; i++){
          var len = incomingXorNodes[key][i].length;
          if(len == 1){
            g.setEdge(incomingXorNodes[key][i][0], str)
          }
          else{
            g.setEdge(incomingXorNodes[key][i][0]+' '+incomingXorNodes[key][i][1], str)
          }
        }
      }
    }
  }

  //Set Up End Node
  var spaces =  endConection.e1.split(' ');
  var k = spaces[0]
  var s = spaces[1]
  if(nodes[k][s].outgoingXOR){
    g.setEdge("XOR-"+k+' '+s, "end")
  }
  else{
    g.setEdge(k+' '+s, "end")
  }

  g.nodes().forEach(function(v) {
    var node = g.node(v);
    // Round the corners of the nodes
    node.rx = node.ry = 5;
  });

  // Set up an SVG group so that we can translate the final graph.
  var svg = d3.select("svg");
  svg.selectAll("*").remove();
  var inner = svg.append("g");

  // Set up zoom support
  var zoom = d3.zoom().on("zoom", function() {
    inner.attr("transform", d3.event.transform);
  });
  svg.call(zoom);

  // Create the renderer
  var render = new dagreD3.render();

  // Run the renderer. This is what draws the final graph.
  render(inner, g);

  // Center the graph
  var initialScale = 0.2;
  svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));

  svg.attr('height', g.graph().height * initialScale + 40);
}

//Simple Comparison Algorithm
var simpleComparison = function(clients, clientIP){
  var size = clients[clientIP].length
  var responses = [];
  var marked = new Array(size).fill(false);
  for(let i = 0; i < size; i++){
    responses[i] = [];
    if(!marked[i]){
      responses[i].push({id : i, client : clients[clientIP][i]})
      marked[i] = true;
      for(let j = i+1; j < size; j++){
        if((clients[clientIP][j].status != responses[i][0].client.status) && (clients[clientIP][j].method == responses[i][0].client.method) &&
        clients[clientIP][j].location == responses[i][0].client.location){
          marked[j] = true;
          responses[i].push({id : j, client : clients[clientIP][j] })
        }
      }
    }
  }
  return responses;
}
//Sequence Preserving Comparison
// var seqPreservingComparison = function(clients, clientIP){
//   var length = clients[clientIP].length;
//   var client = clients[clientIP];
//   // console.log(client)
//   var counterArray = [];
//   var prev = "start";
//   var seqArray = []
//   var endConection = {};
//   for(let i = 0; i < length; i++){
//     var str = client[i].method + client[i].location
//     var status = client[i].status;
//     if(seqArray[str] === undefined){
//       seqArray[str] = {}
//     }
//     var obj = {
//       "start" : prev,
//       "end" : i,
//       "data" : client[i]
//     }
//     if(seqArray[str][status] === undefined){
//       seqArray[str][status] = []
//       prev = i
//     }
//     else{
//       obj.end = seqArray[str][status][0].end
//       prev = seqArray[str][status][0].end
//     }
//     seqArray[str][status].push(obj)
//     if(i == (length-1)){
//       endConection.e1 = prev;
//       console.log('enter');
//     }
//   }
//
//   var counter = 0;
//   for(var key in seqArray){
//     for(var status in seqArray[key]){
//       if(seqArray[key][status].length > 1){
//         counterArray.push(seqArray[key][status][0].end)
//         var bool = false;
//         for(let i = 0; i < seqArray[key][status].length; i++){
//           seqArray[key][status][i].xor = "XOR-" + seqArray[key][status][i].end
//           if(seqArray[key][status][0].end == endConection.e1 && !bool) {
//             endConection.e1 = "XOR-" + seqArray[key][status][0].end;
//             bool = true;
//           }
//         }
//       }
//     }
//   }
//   for(var key in seqArray){
//     for(var status in seqArray[key]){
//       for(let i = 0; i < seqArray[key][status].length; i++){
//         for(let j = 0; j < counterArray.length; j++){
//           if(seqArray[key][status][i].start == counterArray[j]){
//             seqArray[key][status][i].start = "XOR-" + counterArray[j];
//           }
//         }
//       }
//     }
//   }
//   // seqArray = mergeXOR(seqArray);
//   var retObj = {
//     "seqArray" : seqArray,
//     "endConection" : endConection,
//   }
//   console.log(retObj.seqArray);
//   return retObj;
// }
var averageTimeDifference = function(client){
  let avg = 0;
  let min = Number.MAX_VALUE;
  let max = Number.MIN_VALUE
  for(let i = 1; i < client.length; i++){
    let date = new Date(client[i-1].datetime)
    let date1 = new Date(client[i].datetime)
    let diff = Math.abs(date1-date);
    avg+=diff;
    if(max < diff) max = diff
    if(min > diff) min = diff;
  }
  avg /= (client.length-1);
  let days =  (avg / (1000*60*60*24));
  console.log(max,min,avg);
}

//Sequence Preserving Comparison
var seqPreservingComparison = function(clients, clientIP, length){
  var client = clients[clientIP];
  var prev = "start";
  var prevId = "start";
  var endConection = {};
  var edges = []
  var nodes = []
  for(let i = 0; i < length; i++){
    var str = client[i].method + client[i].location
    var status = client[i].status;
    if(nodes[str] === undefined){
      nodes[str] = {}
    }
    var node = {
      "id" : i,
      "startId" : prevId,
      "endId" : i,
      "dataNode" : client[i],
      "start" : prev,
      "end" : str+' '+status,
    }
    if(nodes[str][status] === undefined){
      nodes[str][status] = {
        statusArray : [],
        outgoingXOR : false
      }
    }
    prev = str + ' ' + status;
    prevId = i;
    nodes[str][status].statusArray.push(node)
    if(i == (length-1)){
      endConection.e1 = prev;
    }
  }
  nodes = outgoingXOR(nodes);
  nodes = incomingXOR(nodes);
  nodes.endConection = endConection;
  return nodes;
}
var outgoingXOR = function(nodes){
  var counterArray = []
  var xorTitle;
  for(var key in nodes){
    for(var status in nodes[key]){
      if(nodes[key][status].statusArray.length > 1){
        xorTitle = key + ' ' + status;
        nodes[key][status].outgoingXOR = true;
        counterArray.push(xorTitle);
      }
    }
  }
  for(var key in nodes){
    for(var status in nodes[key]){
      for(let i = 0; i < nodes[key][status].statusArray.length; i++){
        for(let j = 0; j < counterArray.length; j++){
          if(counterArray[j] == nodes[key][status].statusArray[i].start){
            console.log(counterArray[j]);
            nodes[key][status].statusArray[i].start = "XOR-" + counterArray[j];
          }
        }
      }
    }
  }
  return nodes;
}
var incomingXOR = function(nodes){
  var incomingXorKeys = []
  var keyCounter = 0;
  var keyArray = []
  for(var key in nodes){
    keyArray.push(key);
  }
  for(let i = 0; i < keyArray.length; i++){
    for(var key in nodes){
      for(var status in nodes[key]){
        for(let j = 0; j < nodes[key][status].statusArray.length; j++){
          let spaces = nodes[key][status].statusArray[j].end.split(' ');
          if((spaces[0] == "start" && i == 0) || spaces[0] == "XOR-"+keyArray[i] || spaces[0] == keyArray[i]){
            keyCounter++;
          }
        }
      }
    }
    if(keyCounter > 1){
      incomingXorKeys.push({ "key" : keyArray[i], "id" : i})
    }
    keyCounter = 0;
  }
  let incomingXorNodes = {}
  for(let i = 0; i < incomingXorKeys.length; i++){
    for(var key in nodes){
      if(key == incomingXorKeys[i].key){
        for(var status in nodes[key]){
          for(let j = 0; j < nodes[key][status].statusArray.length; j++){
            let spaces = nodes[key][status].statusArray[j].start.split(' ');
            let start = nodes[key][status].statusArray[j].start;
            nodes[key][status].statusArray[j].start = "inXOR-" + key
            if(incomingXorNodes[key] === undefined){
              incomingXorNodes[key] = [];
            }
            incomingXorNodes[key].push(spaces);
          }
        }
      }
    }
  }
  var obj = {
    "nodes" : nodes,
    incomingXorNodes : incomingXorNodes,
  }
  return obj;
}
</script>
</html>
