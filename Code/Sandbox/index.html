<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dagre Interactive Demo</title>

  <script src="https://d3js.org/d3.v4.js"></script>
  <script src="https://dagrejs.github.io/project/graphlib-dot/v0.6.3/graphlib-dot.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <script src="bower_components/graphlib/dist/graphlib.core.js"></script>
  <script src="bower_components/dagre/dist/dagre.core.js"></script>
  <script src="bower_components/dagre-d3/dist/dagre-d3.core.js"></script>
  <link rel="stylesheet/less" type="text/css" href="bower_components/tyles.less" />
  <script src="data.js"></script>
  <script src="sqrfun.js"></script>
  <script src="stylingfun.js"></script>
  <script src="patternMatching.js"></script>
  <script src="patternData.js"></script>
  <!-- <script type="text/javascript" src="setup.js"></script> -->
  <link rel="stylesheet" href="styles.css">

  <body>
    <div id="Container" style="display: flex">
      <div class="dropdown" style="float: left">
        <button class="dropbtn" onmouseover="displayClients()">Dropdown</button>
      </div>
      <select id="multiSelect" multiple="multiple">
      </select>
      <button id="multiSelectForm" type="submit"/> Draw </button>
      <div id="Btns">
      </div>
      <div id="VisualizationConfig" style="display: none">
        Node Frequency Coloring: <input type="checkbox" id="nfc" onclick="myFunction()"> <br />
        Edge Frequency Thickness: <input type="checkbox" id="eft" onclick="myFunction1()"> <br />
        Edge Delay Coloring: <input type="checkbox" id="edc" onclick="myFunction2()">
      </div>
    </div>
    <svg> </g></svg>
  </body>
  <script>
  // Input related code goes here

  // Create the dropdown-list of Clients.
  var displayClients = function(){
    var div = document.getElementsByClassName("dropdown");
    var str = '<div class="dropdown-content"> '
    for(var client in clients){
      str+=('<a onmouseover="displayTimePeriods(\''+ client +'\')" onclick="drawGraph(\''+client +'\')"> '+ client + '</a> ')
    }
    str+=('</div>')
    div[0].innerHTML += str;
  }

  var displayTimePeriods = function(clientIP){
    var client = this.clients[clientIP];
    var el = document.getElementById("multiSelect");
    var form = document.getElementById("multiSelectForm");
    var timePeriods = differenceThreshold(client);
    var str = "";
    for(let i = 0; i < timePeriods.length; i++){
      str += '<option value=\''+i+'\'> Time Period '+ i + '</option>'
    }
    form.onclick = function(){
      getSelectedPeriods(timePeriods);
    }
    el.innerHTML = str;
  }
  var fixVisualizationConfig = function(nfc, eft, edc){
    nfc.checked = false;
    eft.checked = false;
    edc.checked = false;
    deleteStyles();
    disableConversionPaths();
  }
  //Draw the Graph for the selected IP.
  var drawGraph = function(dataObject){
    var g = new dagreD3.graphlib.Graph()
    .setGraph({})
    .setDefaultEdgeLabel(function() { return {}; });

    var nfc = document.getElementById("nfc");
    var eft = document.getElementById("eft");
    var edc = document.getElementById("edc");
    fixVisualizationConfig(nfc, eft, edc);
    // Here we"re setting nodeclass, which is used by our custom drawNodes function
    // below.
    var obj;
    var endConnections = []
    var nodes = []
    var incomingXorNodes = {}
    var totalTpIpArray = []
    var comparisonTableData = {
      timePorIP : [],
      uniqueNodes : {
        size : 0,
      },
      overlappingNodes : {
        size : 0,
      },
      uniqueEdges : { size : 0,},
      overlappingEdges : {size : 0,},
      nodes : {}
    }
    if(dataObject.identify === "tp"){
      var timePeriods = dataObject.data;
      for(let i = 0; i < timePeriods.length; i++){
        var start = "start-"+i;
        g.setNode("start-"+i, {shape: "circle", class : "start" + " tpIpColoring-"+i});
        g.setNode("end-"+i, {shape: "circle", style: "stroke-width: 4; stroke: black", class : "end" + " tpIpColoring-"+i});
        obj = seqPreservingComparison(timePeriods[i], timePeriods[i].length, nodes, start, incomingXorNodes, "end-"+i, i, comparisonTableData)
        incomingXorNodes = obj.incomingXorNodes;
        endConnections.push(obj.endConection);
        nodes = obj.nodes;
        totalTpIpArray.push(i);
        comparisonTableData.timePorIP.push(i);
      }
    }
    else{
      g.setNode("start-0", { shape: "circle", class : "start" + " tpIpColoring-"+0});
      g.setNode("end-0", {shape: "circle", style: "stroke-width: 4; stroke: black", class : "start" + " tpIpColoring-"+0})
      var length = clients[dataObject].length;
      var client = clients[dataObject];
      var start = "start-0"
      obj = seqPreservingComparison(client, length, nodes, start, incomingXorNodes, "end-0", 0, comparisonTableData);
      totalTpIpArray.push(0);
      incomingXorNodes = obj.incomingXorNodes;
      endConnections.push(obj.endConection);
      comparisonTableData.timePorIP.push(0);
      nodes = obj.nodes;
    }
    var endConection = obj.endConection;
    var totalRequestsData = totalNumberOfRequests(nodes);
    var totalRequests = totalRequestsData.total;
    var maxRequests = totalRequestsData.maxRequests;
    comparisonTableData = getComparisonTableNodes(nodes, comparisonTableData);
    for(var key in nodes){
      var size = Object.keys(nodes[key]).length;
      if(size == 1){
        var status = Object.keys(nodes[key])[0]
        var str = "inXOR-"+key
        var word = setUpClassForDifferentIpTp(nodes, key, status);
        if(incomingXorNodes[key] !== undefined) checkIfIncomingXorExists(nodes, key, incomingXorNodes, Object.keys(incomingXorNodes[key]).length, "inXOR-"+key)
        g.setNode(key+' '+status, { shape: "rect", label : nodes[key][status].statusArray[0].key + '\n' + status + '\n' + nodes[key][status].statusArray.length,
        class:"type-Request method-"+key+' '+status + ' ' + word});
        if(nodes[key][status].outgoingXOR){
          g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
        if((nodes[key][status].statusArray.length) > 1 && Object.keys(incomingXorNodes[key]).length > 1){
          // var bool = checkIfIncomingXorExists(nodes, key, status, incomingXorNodes, Object.keys(incomingXorNodes[key]).length, "inXor-"+key);
          var str = "inXOR-"+key
          g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        }
      }
      else{
        var st = Object.keys(nodes[key])[0]
        var word = setUpTotalClassForDifferentIpTp(nodes, key);
        g.setNode(key, {shape: "rect", label: nodes[key][st].statusArray[0].key + '\n' + totalRequests[key], class: "type-Request method-"+key + ' ' + word});
        g.setNode("middleXOR-"+key,{label: "XOR", shape: "diamond", class: "type-XOR"});
        var str = "inXOR-"+key
        if(Object.keys(incomingXorNodes[key]).length > 1) g.setNode(str, {label: "XOR", shape: "diamond", class: "type-XOR"});
        for(var status in nodes[key]){
          word = setUpClassForDifferentIpTp(nodes, key, status);
          g.setNode(key+' '+status, {shape: "rect", label : status + '\n' + nodes[key][status].statusArray.length, class:"type-Response method-"+key+' '+status + ' ' + word});
          if(nodes[key][status].outgoingXOR){
            g.setNode("XOR-"+key+' '+status, {label: "XOR", shape: "diamond", class: "type-XOR"});
          }
        }
      }
    }
    //Compute Delay Avgs
    obj = computeMinMaxAvgDelayVal(nodes);
    nodes = obj.nodes;
    var totalAvgKey = obj.totalAvgKey;
    var maxDelay = obj.MAX;
    var minDelay = obj.MIN;
    var edges = 0;
    //Set Up Edges
    for(var key in nodes){
      var str = "inXOR-"+key
      var size = Object.keys(nodes[key]).length
      var bin = computeAssignBin(totalAvgKey[key].totalDelayAvgKey, maxDelay, 1);
      if(size == 1){
        var status = Object.keys(nodes[key])[0]
        if(nodes[key][status].outgoingXOR){
          // console.log("OUTGOING-Size-1");
          g.setEdge(key+' '+status,"XOR-"+key+' '+status,
          {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin});
          increaseAppropriateEdge(size, key, status, comparisonTableData, "outgoingXOR");
          edges++;
          // console.log(key, status)
          // g.setEdge("inXOR-"+key, key+' '+status, {label: "delayAvg: "+ delayAvg});
        }
        if(nodes[key][status].statusArray.length > 1 && Object.keys(incomingXorNodes[key]).length == 1){
          let space = Object.keys(incomingXorNodes[key])[0]
          let p = getProbabilityLabel(nodes, nodes[key][status].statusArray[0].start.split(' ')[0], nodes[key][status].statusArray[0].start.split(' ')[1], incomingXorNodes[key][space].length);
          g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status,
          {label: p,
           class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin})
           // console.log("INCOMING-Size-1");
          increaseAppropriateEdge(size, key, status, comparisonTableData, "incomingXOR");
          edges++;
        }
        if(nodes[key][status].statusArray.length == 1){
          let p = getProbabilityLabel(nodes, nodes[key][status].statusArray[0].start.split(' ')[0], nodes[key][status].statusArray[0].start.split(' ')[1], 1);
          g.setEdge(nodes[key][status].statusArray[0].start, key+' '+status,
          { label : p,
            class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-" + bin})
            // console.log("INCOMING-STATUS-LENGTH-1");
            increaseAppropriateEdge(size, key, status, comparisonTableData, "incomingXOR");
            edges++;
        }
        if(nodes[key][status].statusArray.length > 1 && Object.keys(incomingXorNodes[key]).length > 1){
          g.setEdge("inXOR-"+key, key+' '+status,
          {class: "edge-thickness-" + nodes[key][status].statusArray.length + " " + "delay-coloring-"+bin})
          increaseAppropriateEdge(size, key, status, comparisonTableData, "incomingXOR");
          edges++;
          // console.log("INCOMING-XOR-SIZE-1")
          // console.log(key, status)
          for(var space in incomingXorNodes[key]){
            var len = incomingXorNodes[key][space][0].length;
            if(len == 1){
              g.setEdge(incomingXorNodes[key][space][0][0], str,
                {class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-0"})
              // console.log("it should be start NODE", incomingXorNodes[key][space][0][0])
              comparisonTableData.uniqueEdges.size++;
              edges++;
              }
              else{
                let avg = getIncomingEdgeIndexDelay(nodes, key, incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], incomingXorNodes[key][space].length);
                bin = computeAssignBin(avg, maxDelay, 1);
                let p = getProbabilityLabel(nodes, incomingXorNodes[key][space][0][0], incomingXorNodes[key][space][0][1], incomingXorNodes[key][space].length);
                g.setEdge(incomingXorNodes[key][space][0][0]+' '+incomingXorNodes[key][space][0][1], str,
                { label : p,
                  class: "edge-thickness-" + incomingXorNodes[key][space].length + " delay-coloring-"+bin})
              }
            }
          }
        }
        else{
          var str1 = "middleXOR-"+key;
          // g.setEdge(str,key,{label: "Delay Average:"+delayAvg});
          if(Object.keys(incomingXorNodes[key]).length > 1){
            g.setEdge(str,key, {
            class: "edge-thickness-"+totalRequests[key] + " " + "delay-coloring-"+bin});
            increaseAppropriateEdge(1, key, status, comparisonTableData, "incomingXOR");
            edges++;
          }
            g.setEdge(key,str1, {class: "edge-thickness-"+totalRequests[key] + " " + "delay-coloring-0"});
            increaseAppropriateEdge(1, key, status, comparisonTableData, "incomingXOR");
            edges++;
            for(var status in nodes[key]){
              // console.log(nodes[key][status].avgDelay);
              bin = computeAssignBin(nodes[key][status].avgDelay, maxDelay, 1);
              g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%",
              class: "edge-thickness-" +nodes[key][status].statusArray.length + " " + "delay-coloring-"+bin})
              increaseAppropriateEdge(1, key, status, comparisonTableData, "middleXOR");
              edges++;
              // g.setEdge(str1,key+' '+status,{label: roundUp(nodes[key][status].statusArray.length/totalRequests[key]*100,1)+"%"+'\n'+"Delay Avg:" + (computeDelayAvg(nodes, key, status)/1000/60/60/24), labelType: "html"});
              if(nodes[key][status].outgoingXOR){
                g.setEdge(key+' '+status, "XOR-"+key+' '+status,
                {class: "edge-thickness-" + nodes[key][status].statusArray.length + " delay-coloring-0"});
                increaseAppropriateEdge(1, key, status, comparisonTableData, "middleXOR");
                edges++;
              }
            }
             multipleIncomingXorSetUp(g, nodes, key, Object.keys(incomingXorNodes[key]).length, maxDelay, 1, incomingXorNodes)
            }
          }
          console.log(comparisonTableData);
          // console.log(edges);
          //Set Up End Node
          for(let i = 0; i < endConnections.length; i++){
            var endConection = endConnections[i];
            var spaces =  endConection.e1.split(' ');
            var k = spaces[0]
            var s = spaces[1]
            if(nodes[k][s].outgoingXOR){
              g.setEdge("XOR-"+k+' '+s, "end-"+i, {
                label : roundUp(1/totalRequests[k]*100,1)+"%",
                class: "edge-thickness-1 delay-coloring-0"})
            }
            else{
              g.setEdge(k+' '+s, "end-"+i, {class: "edge-thickness-1 delay-coloring-0"});
            }
          }
          g.nodes().forEach(function(v) {
            var node = g.node(v);
            // Round the corners of the nodes
            node.rx = node.ry = 5;
          });
          setNodeClasses(g, nodes, totalRequestsData);
          setVisualizationConfig(nfc, eft, edc, maxRequests);
          conversionPath("tpIpColoring", totalTpIpArray.length);
          var patternFound = patternMethondStatus(nodes, pattern);
          var patternFound1 = patternMethondStatusURL(nodes, patternURL);
          var patternFound2 = patternMSUW(nodes, patternWild);
          // patternMethondStatusURL(nodes);
          console.log("PATTERN="+patternFound);
          console.log("PatternURL="+patternFound1);
          console.log("patternWild="+patternFound2);
          var svg = d3.select("svg");
          svg.selectAll("*").remove();
          var inner = svg.append("g");

          // Set up zoom support
          var zoom = d3.zoom().on("zoom", function() {
            inner.attr("transform", d3.event.transform);
          });
          svg.call(zoom);

          // Create the renderer
          var render = new dagreD3.render();
          // Run the renderer. This is what draws the final graph.
          render(inner, g);
          // Center the graph
          var initialScale = 0.2;
          svg.call(zoom.transform, d3.zoomIdentity.translate((svg.attr("width") - g.graph().width * initialScale) / 2, 20).scale(initialScale));
          svg.selectAll("g.node.start").on("click", function(id) { var _node = g.node(id);
            var n = id.split("start-")[1];
            document.body.classList.toggle("enable-path-"+n);
            console.log("Clicked " + id); });
        }

        </script>
        </html>
